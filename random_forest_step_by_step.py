#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
GI·∫¢I B√ÄI T·∫¨P RANDOM FOREST T·ª™NG B∆Ø·ªöC CHI TI·∫æT
Gi·ªëng nh∆∞ gi·∫£ng to√°n tr√™n b·∫£ng
"""

import pandas as pd
import numpy as np
import math

class RandomForestStepByStep:
    """Gi·∫£i Random Forest t·ª´ng b∆∞·ªõc nh∆∞ gi·∫£ng to√°n"""
    
    def __init__(self):
        print("="*70)
        print("üéì B√ÄI GI·∫¢NG: GI·∫¢I RANDOM FOREST T·ª™NG B∆Ø·ªöC")
        print("="*70)
        
    def step1_prepare_data(self):
        """B∆∞·ªõc 1: Chu·∫©n b·ªã d·ªØ li·ªáu"""
        print("\nüìö B∆Ø·ªöC 1: CHU·∫®N B·ªä D·ªÆ LI·ªÜU")
        print("-" * 50)
        
        # D·ªØ li·ªáu g·ªëc
        data = {
            'ID': [1, 2, 3, 4, 5, 6, 7, 8, 9, 10],
            'Gio_hoc': [20, 15, 25, 12, 30, 18, 10, 22, 28, 16],
            'Bai_tap': [8, 6, 10, 4, 9, 7, 3, 8, 10, 5],
            'Diem_danh': [85, 90, 95, 70, 88, 92, 65, 80, 96, 75],
            'Kinh_nghiem': ['C√≥', 'Kh√¥ng', 'C√≥', 'Kh√¥ng', 'C√≥', 'C√≥', 'Kh√¥ng', 'Kh√¥ng', 'C√≥', 'Kh√¥ng'],
            'Ket_qua': ['ƒê·∫≠u', 'R·ªõt', 'ƒê·∫≠u', 'R·ªõt', 'ƒê·∫≠u', 'ƒê·∫≠u', 'R·ªõt', 'R·ªõt', 'ƒê·∫≠u', 'R·ªõt']
        }
        
        self.df = pd.DataFrame(data)
        print("D·ªØ li·ªáu g·ªëc:")
        print(self.df)
        
        # M√£ h√≥a
        print("\nüî¢ M√£ h√≥a d·ªØ li·ªáu:")
        self.df['Kinh_nghiem_encoded'] = self.df['Kinh_nghiem'].map({'C√≥': 1, 'Kh√¥ng': 0})
        self.df['Ket_qua_encoded'] = self.df['Ket_qua'].map({'ƒê·∫≠u': 1, 'R·ªõt': 0})
        
        print("Kinh_nghiem: 'C√≥' = 1, 'Kh√¥ng' = 0")
        print("Ket_qua: 'ƒê·∫≠u' = 1, 'R·ªõt' = 0")
        
        print("\nD·ªØ li·ªáu sau m√£ h√≥a:")
        encoded_df = self.df[['ID', 'Gio_hoc', 'Bai_tap', 'Diem_danh', 'Kinh_nghiem_encoded', 'Ket_qua_encoded']]
        encoded_df.columns = ['ID', 'Gio_hoc', 'Bai_tap', 'Diem_danh', 'Kinh_nghiem', 'Ket_qua']
        print(encoded_df)
        
        return encoded_df
    
    def step2_create_bootstrap_sample(self, df):
        """B∆∞·ªõc 2: T·∫°o Bootstrap Sample"""
        print("\nüå≤ B∆Ø·ªöC 2: T·∫†O BOOTSTRAP SAMPLES")
        print("-" * 50)
        
        print("üìñ L√Ω thuy·∫øt Bootstrap:")
        print("- L·∫•y m·∫´u c√≥ ho√†n l·∫°i t·ª´ t·∫≠p g·ªëc")
        print("- K√≠ch th∆∞·ªõc = t·∫≠p g·ªëc (10 m·∫´u)")
        print("- M·ªói m·∫´u c√≥ th·ªÉ xu·∫•t hi·ªán nhi·ªÅu l·∫ßn")
        
        # Bootstrap Sample 1 (gi·∫£ s·ª≠ random ƒë∆∞·ª£c)
        bootstrap_indices = [1, 3, 5, 6, 9, 2, 8, 5, 1, 10]  # indices (1-based)
        bootstrap_indices_0 = [i-1 for i in bootstrap_indices]  # convert to 0-based
        
        print(f"\nüé≤ Gi·∫£ s·ª≠ random ch·ªçn ƒë∆∞·ª£c indices: {bootstrap_indices}")
        
        bootstrap_sample = df.iloc[bootstrap_indices_0].copy()
        bootstrap_sample.reset_index(drop=True, inplace=True)
        
        print("\nBootstrap Sample 1:")
        print(bootstrap_sample)
        
        # Ph√¢n t√≠ch ph√¢n b·ªë
        dau_count = sum(bootstrap_sample['Ket_qua'])
        rot_count = len(bootstrap_sample) - dau_count
        
        print(f"\nüìä Ph√¢n b·ªë trong Sample 1:")
        print(f"- ƒê·∫≠u (1): {dau_count} m·∫´u")
        print(f"- R·ªõt (0): {rot_count} m·∫´u")
        
        return bootstrap_sample
    
    def calculate_entropy(self, labels):
        """T√≠nh entropy"""
        if len(labels) == 0:
            return 0
        
        unique_labels, counts = np.unique(labels, return_counts=True)
        probabilities = counts / len(labels)
        
        entropy = 0
        for p in probabilities:
            if p > 0:
                entropy -= p * math.log2(p)
        
        return entropy
    
    def step3_build_tree1(self, sample):
        """B∆∞·ªõc 3: X√¢y d·ª±ng c√¢y quy·∫øt ƒë·ªãnh 1"""
        print("\nüìä B∆Ø·ªöC 3: X√ÇY D·ª∞NG C√ÇY QUY·∫æT ƒê·ªäNH 1")
        print("-" * 50)
        
        print("‚öôÔ∏è Thi·∫øt l·∫≠p tham s·ªë:")
        print("- max_features = 2: M·ªói n√∫t ch·ªâ xem x√©t 2/4 ƒë·∫∑c tr∆∞ng")
        print("- T·ªïng features: {Gio_hoc, Bai_tap, Diem_danh, Kinh_nghiem}")
        
        print("\nüéØ T·∫†I N√öT G·ªêC:")
        print("Random ch·ªçn 2 features: {Gio_hoc, Kinh_nghiem}")
        
        # T√≠nh Entropy ban ƒë·∫ßu
        print("\nüìê T√çNH ENTROPY BAN ƒê·∫¶U:")
        labels = sample['Ket_qua'].values
        initial_entropy = self.calculate_entropy(labels)
        
        total_samples = len(labels)
        dau_count = sum(labels)
        rot_count = total_samples - dau_count
        
        print(f"T·ªïng m·∫´u: {total_samples}")
        print(f"ƒê·∫≠u: {dau_count} m·∫´u ‚Üí p‚ÇÅ = {dau_count}/{total_samples} = {dau_count/total_samples:.3f}")
        print(f"R·ªõt: {rot_count} m·∫´u ‚Üí p‚ÇÇ = {rot_count}/{total_samples} = {rot_count/total_samples:.3f}")
        
        print(f"\nC√¥ng th·ª©c: Entropy(S) = -Œ£ p·µ¢ √ó log‚ÇÇ(p·µ¢)")
        print(f"Entropy(S) = -({dau_count/total_samples:.3f} √ó log‚ÇÇ({dau_count/total_samples:.3f})) - ({rot_count/total_samples:.3f} √ó log‚ÇÇ({rot_count/total_samples:.3f}))")
        
        if dau_count > 0:
            term1 = (dau_count/total_samples) * math.log2(dau_count/total_samples)
        else:
            term1 = 0
            
        if rot_count > 0:
            term2 = (rot_count/total_samples) * math.log2(rot_count/total_samples)
        else:
            term2 = 0
            
        print(f"         = -({term1:.3f}) - ({term2:.3f})")
        print(f"         = {-term1:.3f} + {-term2:.3f}")
        print(f"         = {initial_entropy:.3f}")
        
        # T√≠nh Information Gain cho Kinh_nghiem
        print("\nüßÆ T√çNH INFORMATION GAIN CHO KINH_NGHIEM:")
        
        # Split theo Kinh_nghiem
        co_mask = sample['Kinh_nghiem'] == 1
        khong_mask = sample['Kinh_nghiem'] == 0
        
        co_labels = sample[co_mask]['Ket_qua'].values
        khong_labels = sample[khong_mask]['Ket_qua'].values
        
        print(f"\nKinh_nghiem = 1 (C√≥):")
        print(f"- M·∫´u: {list(sample[co_mask]['ID'].values)} = {len(co_labels)} m·∫´u")
        print(f"- ƒê·∫≠u: {sum(co_labels)}, R·ªõt: {len(co_labels) - sum(co_labels)}")
        
        co_entropy = self.calculate_entropy(co_labels)
        print(f"- Entropy = {co_entropy:.3f} {'(thu·∫ßn khi·∫øt)' if co_entropy == 0 else ''}")
        
        print(f"\nKinh_nghiem = 0 (Kh√¥ng):")
        print(f"- M·∫´u: {list(sample[khong_mask]['ID'].values)} = {len(khong_labels)} m·∫´u")
        print(f"- ƒê·∫≠u: {sum(khong_labels)}, R·ªõt: {len(khong_labels) - sum(khong_labels)}")
        
        khong_entropy = self.calculate_entropy(khong_labels)
        print(f"- Entropy = {khong_entropy:.3f} {'(thu·∫ßn khi·∫øt)' if khong_entropy == 0 else ''}")
        
        # Information Gain
        weighted_entropy = (len(co_labels)/total_samples) * co_entropy + (len(khong_labels)/total_samples) * khong_entropy
        ig_kinh_nghiem = initial_entropy - weighted_entropy
        
        print(f"\nInformation Gain:")
        print(f"IG = Entropy_ban_ƒë·∫ßu - Œ£(|S·µ•|/|S|) √ó Entropy(S·µ•)")
        print(f"   = {initial_entropy:.3f} - ({len(co_labels)}/{total_samples} √ó {co_entropy:.3f} + {len(khong_labels)}/{total_samples} √ó {khong_entropy:.3f})")
        print(f"   = {initial_entropy:.3f} - {weighted_entropy:.3f}")
        print(f"   = {ig_kinh_nghiem:.3f}")
        
        # T√≠nh Information Gain cho Gio_hoc (ƒë∆°n gi·∫£n h√≥a)
        print("\nüßÆ T√çNH INFORMATION GAIN CHO GIO_HOC:")
        
        threshold = sample['Gio_hoc'].median()
        print(f"Ch·ªçn threshold = median = {threshold}")
        
        le_mask = sample['Gio_hoc'] <= threshold
        gt_mask = sample['Gio_hoc'] > threshold
        
        le_labels = sample[le_mask]['Ket_qua'].values
        gt_labels = sample[gt_mask]['Ket_qua'].values
        
        print(f"\nGio_hoc ‚â§ {threshold}:")
        print(f"- M·∫´u: {len(le_labels)} m·∫´u, ƒê·∫≠u: {sum(le_labels)}, R·ªõt: {len(le_labels) - sum(le_labels)}")
        
        le_entropy = self.calculate_entropy(le_labels)
        print(f"- Entropy = {le_entropy:.3f}")
        
        print(f"\nGio_hoc > {threshold}:")
        print(f"- M·∫´u: {len(gt_labels)} m·∫´u, ƒê·∫≠u: {sum(gt_labels)}, R·ªõt: {len(gt_labels) - sum(gt_labels)}")
        
        gt_entropy = self.calculate_entropy(gt_labels)
        print(f"- Entropy = {gt_entropy:.3f}")
        
        weighted_entropy_gio = (len(le_labels)/total_samples) * le_entropy + (len(gt_labels)/total_samples) * gt_entropy
        ig_gio_hoc = initial_entropy - weighted_entropy_gio
        
        print(f"\nInformation Gain:")
        print(f"IG = {initial_entropy:.3f} - ({len(le_labels)}/{total_samples} √ó {le_entropy:.3f} + {len(gt_labels)}/{total_samples} √ó {gt_entropy:.3f})")
        print(f"   = {initial_entropy:.3f} - {weighted_entropy_gio:.3f}")
        print(f"   = {ig_gio_hoc:.3f}")
        
        # So s√°nh v√† ch·ªçn feature
        print(f"\nüèÜ SO S√ÅNH V√Ä CH·ªåN FEATURE:")
        print(f"IG(Kinh_nghiem) = {ig_kinh_nghiem:.3f}")
        print(f"IG(Gio_hoc) = {ig_gio_hoc:.3f}")
        
        if ig_kinh_nghiem > ig_gio_hoc:
            print(f"\n‚úÖ Ch·ªçn Kinh_nghiem l√†m root (IG cao h∆°n)")
            chosen_feature = "Kinh_nghiem"
        else:
            print(f"\n‚úÖ Ch·ªçn Gio_hoc l√†m root (IG cao h∆°n)")
            chosen_feature = "Gio_hoc"
        
        # V·∫Ω c√¢y
        print(f"\nüå≥ C√ÇY QUY·∫æT ƒê·ªäNH 1 HO√ÄN CH·ªàNH:")
        print("```")
        if chosen_feature == "Kinh_nghiem":
            print("                Kinh_nghiem")
            print("                    /    \\")
            print("                 C√≥           Kh√¥ng")
            print("                /               \\")
            if co_entropy == 0:
                co_result = "ƒê·∫≠u" if sum(co_labels) > 0 else "R·ªõt"
                print(f"           {co_result} ({sum(co_labels)}/{len(co_labels)})         ", end="")
            if khong_entropy == 0:
                khong_result = "ƒê·∫≠u" if sum(khong_labels) > 0 else "R·ªõt"
                print(f"{khong_result} ({sum(khong_labels)}/{len(khong_labels)})")
            
            print(f"        P(ƒê·∫≠u) = {sum(co_labels)/len(co_labels):.1f}      P(ƒê·∫≠u) = {sum(khong_labels)/len(khong_labels):.1f}")
        
        print("```")
        
        return {
            'feature': chosen_feature,
            'co_prob': sum(co_labels)/len(co_labels) if len(co_labels) > 0 else 0,
            'khong_prob': sum(khong_labels)/len(khong_labels) if len(khong_labels) > 0 else 0
        }
    
    def step4_predict_new_student(self, tree1_info):
        """B∆∞·ªõc 4: D·ª± ƒëo√°n sinh vi√™n m·ªõi"""
        print("\nüéØ B∆Ø·ªöC 4: D·ª∞ ƒêO√ÅN SINH VI√äN M·ªöI")
        print("-" * 50)
        
        print("üë§ Profile sinh vi√™n X:")
        student_x = {
            'Gio_hoc': 24,
            'Bai_tap': 8,
            'Diem_danh': 87,
            'Kinh_nghiem': 1  # C√≥
        }
        
        for key, value in student_x.items():
            print(f"- {key}: {value}")
        
        print("\nüå≥ D·ª∞ ƒêO√ÅN T·ª™NG C√ÇY:")
        
        # C√¢y 1
        print("\nüìä C√¢y 1:")
        if tree1_info['feature'] == 'Kinh_nghiem':
            if student_x['Kinh_nghiem'] == 1:
                prob1 = tree1_info['co_prob']
                result1 = "ƒê·∫≠u" if prob1 > 0.5 else "R·ªõt"
                print(f"Kinh_nghiem = 1 (C√≥) ‚Üí ƒëi nh√°nh tr√°i ‚Üí {result1}")
                print(f"P(ƒê·∫≠u) = {prob1:.3f}")
            else:
                prob1 = tree1_info['khong_prob']
                result1 = "ƒê·∫≠u" if prob1 > 0.5 else "R·ªõt"
                print(f"Kinh_nghiem = 0 (Kh√¥ng) ‚Üí ƒëi nh√°nh ph·∫£i ‚Üí {result1}")
                print(f"P(ƒê·∫≠u) = {prob1:.3f}")
        
        # C√¢y 2 (gi·∫£ s·ª≠)
        print("\nüìä C√¢y 2 (gi·∫£ s·ª≠):")
        print("Bai_tap = 8 ‚â• 7 ‚Üí ƒëi nh√°nh tr√°i")
        print("Diem_danh = 87% < 90% ‚Üí ƒëi nh√°nh ph·∫£i ‚Üí R·ªõt")
        prob2 = 0.25
        print(f"P(ƒê·∫≠u) = {prob2:.3f}")
        
        # C√¢y 3 (gi·∫£ s·ª≠)
        print("\nüìä C√¢y 3 (gi·∫£ s·ª≠):")
        print("Gio_hoc = 24 ‚â• 18 ‚Üí ƒëi nh√°nh tr√°i ‚Üí ƒê·∫≠u")
        prob3 = 0.83
        print(f"P(ƒê·∫≠u) = {prob3:.3f}")
        
        # Ensemble
        print("\nüéØ K·∫æT H·ª¢P K·∫æT QU·∫¢ (ENSEMBLE):")
        
        print("\nüìä Ph∆∞∆°ng ph√°p 1: Majority Voting")
        votes = []
        if prob1 > 0.5:
            votes.append("ƒê·∫≠u")
        else:
            votes.append("R·ªõt")
            
        if prob2 > 0.5:
            votes.append("ƒê·∫≠u") 
        else:
            votes.append("R·ªõt")
            
        if prob3 > 0.5:
            votes.append("ƒê·∫≠u")
        else:
            votes.append("R·ªõt")
        
        print(f"C√¢y 1: {votes[0]}")
        print(f"C√¢y 2: {votes[1]}")
        print(f"C√¢y 3: {votes[2]}")
        
        dau_votes = votes.count("ƒê·∫≠u")
        rot_votes = votes.count("R·ªõt")
        
        if dau_votes > rot_votes:
            majority_result = "ƒê·∫≠u"
        else:
            majority_result = "R·ªõt"
            
        print(f"\nK·∫øt qu·∫£: {majority_result} ({dau_votes}/3 phi·∫øu)")
        
        print("\nüìä Ph∆∞∆°ng ph√°p 2: Probability Averaging")
        avg_prob = (prob1 + prob2 + prob3) / 3
        print(f"P(ƒê·∫≠u) = ({prob1:.3f} + {prob2:.3f} + {prob3:.3f}) / 3 = {avg_prob:.3f}")
        print(f"‚Üí {avg_prob*100:.1f}% kh·∫£ nƒÉng ƒë·∫≠u")
        
        return avg_prob
    
    def step5_conclusion(self, final_prob):
        """B∆∞·ªõc 5: K·∫øt lu·∫≠n"""
        print("\nüìù B∆Ø·ªöC 5: K·∫æT LU·∫¨N")
        print("-" * 50)
        
        print("üèÜ ƒê√ÅP √ÅN CU·ªêI C√ôNG:")
        print(f"Sinh vi√™n X c√≥ {final_prob*100:.1f}% kh·∫£ nƒÉng ƒê·∫¨U m√¥n Khai ph√° d·ªØ li·ªáu")
        
        print("\nüí° GI·∫¢I TH√çCH K·∫æT QU·∫¢:")
        print("- C√¢y 1 d·ª± ƒëo√°n ƒê·∫≠u v√¨ sinh vi√™n c√≥ kinh nghi·ªám l·∫≠p tr√¨nh")
        print("- C√¢y 2 d·ª± ƒëo√°n R·ªõt v√¨ ƒëi·ªÉm danh th·∫•p (87% < 90%)")
        print("- C√¢y 3 d·ª± ƒëo√°n ƒê·∫≠u v√¨ h·ªçc nhi·ªÅu gi·ªù (24 ‚â• 18)")
        
        print("\n‚ú® ∆∞u ƒëi·ªÉm Random Forest th·ªÉ hi·ªán:")
        print("1. ƒêa d·∫°ng: 3 c√¢y nh√¨n t·ª´ g√≥c ƒë·ªô kh√°c nhau")
        print("2. Robust: Kh√¥ng ph·ª• thu·ªôc v√†o 1 c√¢y duy nh·∫•t")
        print("3. Confidence: Cho ra x√°c su·∫•t thay v√¨ ch·ªâ yes/no")
        
    def solve_complete_problem(self):
        """Gi·∫£i to√†n b·ªô b√†i to√°n"""
        print("üöÄ B·∫ÆT ƒê·∫¶U GI·∫¢I B√ÄI TO√ÅN RANDOM FOREST")
        
        # B∆∞·ªõc 1: Chu·∫©n b·ªã d·ªØ li·ªáu
        df = self.step1_prepare_data()
        
        # B∆∞·ªõc 2: T·∫°o bootstrap sample
        bootstrap_sample = self.step2_create_bootstrap_sample(df)
        
        # B∆∞·ªõc 3: X√¢y d·ª±ng c√¢y 1
        tree1_info = self.step3_build_tree1(bootstrap_sample)
        
        # B∆∞·ªõc 4: D·ª± ƒëo√°n sinh vi√™n m·ªõi
        final_prob = self.step4_predict_new_student(tree1_info)
        
        # B∆∞·ªõc 5: K·∫øt lu·∫≠n
        self.step5_conclusion(final_prob)
        
        print("\nüéâ HO√ÄN TH√ÄNH B√ÄI GI·∫¢NG!")
        print("üìö Hy v·ªçng c√°c b·∫°n ƒë√£ hi·ªÉu r√µ c√°ch gi·∫£i Random Forest!")

if __name__ == "__main__":
    # Kh·ªüi t·∫°o v√† gi·∫£i b√†i to√°n
    teacher = RandomForestStepByStep()
    teacher.solve_complete_problem()

